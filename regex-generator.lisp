(in-package :regex-generator)

(defvar *register-number*)
(defvar *registers*)

(defgeneric generate-simple-parse-tree (parse-tree)
  (:method ((parse-tree character))
    parse-tree)
  (:method ((parse-tree string))
    parse-tree)
  (:method ((parse-tree (eql :void)))
    "")
  (:method ((parse-tree (eql :word-boundary))))
  (:method ((parse-tree (eql :non-word-boundary))))
  (:method ((parse-tree (eql :everything)))
    (random-char))
  (:method ((parse-tree (eql :digit-class)))
    (random-digit-char))
  (:method ((parse-tree (eql :word-char-class)))
    (random-word-char))
  (:method ((parse-tree (eql :whitespace-char-class)))
    (random-whitespace-char))
  (:method ((parse-tree (eql :non-digit-class)))
    (random-non-digit-char))
  (:method ((parse-tree (eql :non-word-char-class)))
    (random-non-word-char))
  (:method ((parse-tree (eql :non-whitespace-char-class)))
    (random-non-whitespace-char))
  (:method ((parse-tree (eql :start-anchor))))
  (:method ((parse-tree (eql :end-anchor))))
  (:method ((parse-tree (eql :modeless-start-anchor))))
  (:method ((parse-tree (eql :modeless-end-anchor))))
  (:method ((parse-tree (eql :modeless-end-anchor-no-newline))))
  (:method ((parse-tree (eql :case-insensitive-p))))
  (:method ((parse-tree (eql :case-sensitive-p))))
  (:method ((parse-tree (eql :multi-line-mode-p))))
  (:method ((parse-tree (eql :not-multi-line-mode-p))))
  (:method ((parse-tree (eql :single-line-mode-p))))
  (:method ((parse-tree (eql :not-single-line-mode-p)))))

(defun generate-sequence (arguments)
  (with-output-to-string (out)
    (dolist (parse-tree arguments)
      (when-let (string (generate-aux parse-tree))
        (princ string out)))))

(defun generate-char-class (item)
  (cond ((characterp item)
         item)
        ((symbolp item)
         (ecase item
           ((:digit-class)
            (random-digit-char))
           ((:non-digit-class)
            (random-non-digit-char))
           ((:whitespace-char-class)
            (random-whitespace-char))
           ((:non-whitespace-char-class)
            (random-non-whitespace-char))
           ((:word-char-class)
            (random-word-char))
           ((:non-word-char-class)
            (random-non-word-char))))
        ((and (consp item)
              (eq (first item) :property))
         (error "unsupported inverted-property"))
        ((and (consp item)
              (eq (first item) :inverted-property))
         (error "unsupported inverted-property"))
        ((and (consp item)
              (eq (first item) :range))
         (destructuring-bind (min max) (rest item)
           (code-char (random-integer (char-code min) (char-code max)))))
        (t (error "Unknown item ~A in char-class list." item))))

(defgeneric generate-compound-parse-tree (token parse-tree)
  (:method ((token (eql :sequence)) parse-tree)
    (generate-sequence (rest parse-tree)))
  (:method ((token (eql :alternation)) parse-tree)
    (generate-aux (random-choice (rest parse-tree))))
  (:method ((token (eql :group)) parse-tree)
    (if (cddr parse-tree)
        (generate-sequence (rest parse-tree))
        (generate-aux (second parse-tree))))
  (:method ((token (eql :char-class)) parse-tree)
    (let ((item (random-choice (rest parse-tree))))
      (generate-char-class item)))
  (:method ((token (eql :greedy-repetition)) parse-tree)
    (destructuring-bind (min max regex) (rest parse-tree)
      (with-output-to-string (out)
        (cond ((and (zerop min)
                    (null max)
                    (zerop (random 3)))
               ;; regex*の場合は1/3の確率で空文字列にする、
               ;; これをしないと1/+max-repetition+の確率でしか空文字列にならないため
               nil)
              (t
               (loop :repeat (random-integer min (or max +max-repetition+))
                     :do (when-let (string (generate-aux regex))
                           (princ string out))))))))
  (:method ((token (eql :register)) parse-tree)
    (destructuring-bind (regex) (rest parse-tree)
      (let ((string (generate-aux regex)))
        (vector-push-extend string *registers*)
        string)))
  (:method ((token (eql :back-reference)) parse-tree)
    (destructuring-bind (index) (rest parse-tree)
      (aref *registers* (1- index)))))

(defun generate-aux (parse-tree)
  (if (consp parse-tree)
      (generate-compound-parse-tree (first parse-tree) parse-tree)
      (generate-simple-parse-tree parse-tree)))

(defun generate (regex)
  (let ((parse-tree (typecase regex
                      (string
                       (ppcre:parse-string regex))
                      (otherwise
                       regex)))
        (*register-number* 0)
        (*registers* (make-array 0 :adjustable t :fill-pointer 0)))
    (generate-aux parse-tree)))
